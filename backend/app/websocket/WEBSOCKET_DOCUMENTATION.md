# WebSocket - DocumentaciÃ³n TÃ©cnica para Frontend

## ğŸ†• **NUEVA FUNCIONALIDAD: GestiÃ³n de Estado de Usuarios**
> **Â¡IMPORTANTE!** Se ha aÃ±adido gestiÃ³n completa de estados de usuario via WebSocket.
> 
> Ver documentaciÃ³n detallada en:
> - ğŸ“‹ **DocumentaciÃ³n completa**: `WEBSOCKET_USER_STATUS_DOCUMENTATION.md`
> - âš¡ **Referencia rÃ¡pida**: `WEBSOCKET_QUICK_REFERENCE.md`

### Estados AutomÃ¡ticos
- Al **conectar** WebSocket â†’ Usuario se marca como `connected`
- Al **desconectar** WebSocket â†’ Usuario se marca como `disconnected`

### Nuevos Mensajes WebSocket
- `update_user_status` - Cambiar estado propio
- `user_status_changed` - NotificaciÃ³n de cambio de estado de otros usuarios

---

## GarantÃ­a del Campo `type`

El servidor garantiza que TODOS los mensajes salientes incluirÃ¡n el campo `type` como una cadena.
Esto facilita el enrutado en el frontend via `message.type`. Algunos valores canÃ³nicos incluyen:

- `player_connected`, `player_disconnected`, `player_left_game`
- `update_user_status`, `user_status_changed`, `user_status_update`
- `join_game`, `start_game`, `restart_game`, `get_game_status`, `force_next_phase`
- `cast_vote`, `get_voting_status`, `vote_cast`, `voting_started`, `voting_ended`, `voting_results`
- `phase_changed`, `phase_timer`, `game_started`, `game_ended`
- `role_action`, `night_action`, `player_eliminated`, `player_role_revealed`
- `heartbeat`, `error`, `success`, `system_message`, `game_connection_state`, `players_status_update`, `user_connection_status`

Si por alguna razÃ³n un emisor interno no especifica `type`, el servidor lo normalizarÃ¡ a `system_message`.

---

## ConexiÃ³n WebSocket

### Endpoint
```
ws://localhost:8000/ws/{game_id}?token={access_token}
```

### ParÃ¡metros de ConexiÃ³n
- **game_id** (string): ID Ãºnico del juego al que se desea conectar
- **token** (string, query parameter): Token JWT de autenticaciÃ³n obtenido del endpoint `/login`

### AutenticaciÃ³n
El WebSocket requiere autenticaciÃ³n obligatoria:
1. Realizar login via POST `/login` para obtener `access_token`
2. Incluir el token como query parameter en la URL de conexiÃ³n
3. El token serÃ¡ validado al momento de la conexiÃ³n

### Ejemplo de ConexiÃ³n (JavaScript)
```javascript
// 1. Primero hacer login
const loginResponse = await fetch('http://localhost:8000/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
  body: 'username=tu_usuario&password=tu_password'
});
const { access_token } = await loginResponse.json();

// 2. Conectar WebSocket
const gameId = 'game-123';
const ws = new WebSocket(`ws://localhost:8000/ws/${gameId}?token=${access_token}`);
```

---

## Tipos de Mensajes

### Estructura Base
Todos los mensajes siguen esta estructura base:
```json
{
  "type": "message_type",
  "timestamp": "2025-01-30T22:00:00Z",
  "game_id": "game-123",
  // ... campos especÃ­ficos del mensaje
}
```

### 1. Mensajes de ConexiÃ³n

#### PLAYER_CONNECTED
Se recibe cuando un jugador se conecta al juego:
```json
{
  "type": "player_connected",
  "user_id": "user123",
  "username": "PlayerName",
  "timestamp": "2025-01-30T22:00:00Z",
  "game_id": "game-123"
}
```

#### PLAYER_DISCONNECTED
Se recibe cuando un jugador se desconecta:
```json
{
  "type": "player_disconnected",
  "user_id": "user123",
  "timestamp": "2025-01-30T22:00:00Z",
  "game_id": "game-123"
}
```

### 2. Comandos de Juego (EnvÃ­o)

#### JOIN_GAME
Para unirse a un juego:
```json
{
  "type": "join_game"
}
```

#### START_GAME
Para iniciar el juego (requiere permisos de admin/creador):
```json
{
  "type": "start_game"
}
```

#### GET_GAME_STATUS
Para obtener el estado actual del juego:
```json
{
  "type": "get_game_status"
}
```

#### FORCE_NEXT_PHASE
Para forzar cambio a la siguiente fase (admin):
```json
{
  "type": "force_next_phase"
}
```

### 3. Eventos de Juego (RecepciÃ³n)

#### GAME_STARTED
Se recibe cuando el juego se inicia:
```json
{
  "type": "game_started",
  "players": [
    {"id": "user1", "name": "Player1"},
    {"id": "user2", "name": "Player2"}
  ],
  "roles_assigned": true,
  "timestamp": "2025-01-30T22:00:00Z"
}
```

#### PHASE_CHANGED
Se recibe cuando cambia la fase del juego:
```json
{
  "type": "phase_changed",
  "phase": "night", // night, day, voting, trial, execution
  "duration": 60, // duraciÃ³n en segundos
  "timestamp": "2025-01-30T22:00:00Z"
}
```

#### PHASE_TIMER
Se recibe periÃ³dicamente durante las fases para mostrar tiempo restante:
```json
{
  "type": "phase_timer",
  "phase": "night",
  "time_remaining": 45, // segundos restantes
  "timestamp": "2025-01-30T22:00:00Z"
}
```

### 4. Sistema de VotaciÃ³n

#### CAST_VOTE (EnvÃ­o)
Para emitir un voto:
```json
{
  "type": "cast_vote",
  "target_id": "user123"
}
```

#### VOTE_CAST (RecepciÃ³n)
Se recibe cuando alguien vota:
```json
{
  "type": "vote_cast",
  "voter_id": "user456",
  "target_id": "user123",
  "vote_type": "day_vote",
  "timestamp": "2025-01-30T22:00:00Z"
}
```

#### GET_VOTING_STATUS (EnvÃ­o)
Para obtener el estado actual de la votaciÃ³n:
```json
{
  "type": "get_voting_status"
}
```

#### VOTING_RESULTS (RecepciÃ³n)
Se recibe al finalizar una votaciÃ³n:
```json
{
  "type": "voting_results",
  "vote_type": "day_vote",
  "results": {
    "user123": 3,
    "user456": 2
  },
  "eliminated_player": "user123",
  "is_tie": false,
  "timestamp": "2025-01-30T22:00:00Z"
}
```

### 5. Sistema de Chat

#### CHAT_MESSAGE (EnvÃ­o)
Para enviar mensaje de chat:
```json
{
  "type": "chat_message",
  "message": "Hola a todos!",
  "channel": "all" // all, living, dead, wolves
}
```

#### CHAT_MESSAGE (RecepciÃ³n)
Se recibe cuando alguien envÃ­a un mensaje:
```json
{
  "type": "chat_message",
  "sender_id": "user123",
  "sender_name": "PlayerName",
  "message": "Hola a todos!",
  "channel": "all",
  "timestamp": "2025-01-30T22:00:00Z"
}
```

### 6. Mensajes del Sistema

#### SYSTEM_MESSAGE
Mensajes informativos del sistema:
```json
{
  "type": "system_message",
  "message": "Estado del juego: night",
  "message_key": "game_status_update", // para i18n
  "params": {"phase": "night"},
  "data": {
    "game_id": "game-123",
    "phase": "night",
    "players": [
      {
        "id": "user1",
        "name": "Player1",
        "is_alive": true,
        "is_connected": true,
        "role": "villager"
      }
    ],
    "connected_players": ["user1", "user2"],
    "living_players": ["user1", "user2"],
    "dead_players": [],
    "time_remaining": 45
  },
  "timestamp": "2025-01-30T22:00:00Z"
}
```

### 7. Heartbeat/Ping

#### HEARTBEAT (EnvÃ­o/RecepciÃ³n)
Para mantener la conexiÃ³n viva:
```json
{
  "type": "heartbeat",
  "timestamp": "2025-01-30T22:00:00Z"
}
```

Respuesta del servidor:
```json
{
  "type": "heartbeat",
  "response": "pong",
  "timestamp": "2025-01-30T22:00:00Z"
}
```

### 8. Manejo de Errores

#### ERROR
Se recibe cuando ocurre un error:
```json
{
  "type": "error",
  "error_code": "INVALID_MESSAGE",
  "message": "Tipo de mensaje requerido",
  "details": {},
  "timestamp": "2025-01-30T22:00:00Z"
}
```

**CÃ³digos de error comunes:**
- `INVALID_MESSAGE`: Mensaje mal formado
- `INVALID_MESSAGE_TYPE`: Tipo de mensaje no vÃ¡lido
- `CONNECTION_NOT_FOUND`: ConexiÃ³n no encontrada
- `USER_NOT_FOUND`: Usuario no encontrado
- `GAME_NOT_FOUND`: Juego no encontrado
- `VOTE_FAILED`: Error en votaciÃ³n
- `INTERNAL_ERROR`: Error interno del servidor
- `INVALID_TOKEN`: Token invÃ¡lido
- `NO_PERMISSIONS`: Sin permisos para la acciÃ³n

#### SUCCESS
Se recibe para confirmar acciones exitosas:
```json
{
  "type": "success",
  "action": "vote_cast",
  "message": "Voto registrado correctamente",
  "data": {},
  "timestamp": "2025-01-30T22:00:00Z"
}
```

---

## Eventos de Roles Especiales

### ROLE_ACTION
Para acciones especÃ­ficas de roles:
```json
{
  "type": "role_action",
  "actor_id": "user123",
  "action": "see", // see, heal, poison, shoot, etc
  "target_id": "user456",
  "timestamp": "2025-01-30T22:00:00Z"
}
```

### PLAYER_ELIMINATED
Cuando un jugador es eliminado:
```json
{
  "type": "player_eliminated",
  "player_id": "user123",
  "player_name": "PlayerName",
  "role": "villager",
  "elimination_type": "vote", // vote, night_kill, poison, etc
  "timestamp": "2025-01-30T22:00:00Z"
}
```

---

## Funcionalidades AutomÃ¡ticas

### 1. Auto-inicio de Juegos
- Cuando se alcanza el nÃºmero mÃ¡ximo de jugadores, el juego se inicia automÃ¡ticamente
- Se envÃ­a mensaje `GAME_STARTED` a todos los conectados

### 2. Heartbeat AutomÃ¡tico
- El servidor envÃ­a pings cada 30 segundos
- Conexiones que no respondan son eliminadas automÃ¡ticamente

### 3. GestiÃ³n de Rooms
- Los jugadores se agrupan automÃ¡ticamente por `game_id`
- Los mensajes se envÃ­an solo a jugadores del mismo juego
- Desconexiones se notifican automÃ¡ticamente al resto

### 4. Sistema de Fases
- Cambios de fase automÃ¡ticos con timers
- Notificaciones de tiempo restante
- Callbacks para eventos de fase

---

## ImplementaciÃ³n Frontend Recomendada

### 1. Manejo de ConexiÃ³n
```javascript
class GameWebSocket {
  constructor(gameId, token) {
    this.gameId = gameId;
    this.token = token;
    this.ws = null;
    this.eventHandlers = {};
  }

  connect() {
    const url = `ws://localhost:8000/ws/${this.gameId}?token=${this.token}`;
    this.ws = new WebSocket(url);
    
    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.sendMessage({ type: 'join_game' });
    };
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };
    
    this.ws.onclose = (event) => {
      console.log('WebSocket closed:', event.code, event.reason);
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }

  handleMessage(message) {
    const handler = this.eventHandlers[message.type];
    if (handler) {
      handler(message);
    }
  }

  on(eventType, handler) {
    this.eventHandlers[eventType] = handler;
  }

  sendMessage(message) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }
}
```

### 2. Uso en Vue Component
```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const gameWs = ref(null)
const players = ref([])
const currentPhase = ref('')
const timeRemaining = ref(0)

onMounted(() => {
  // Asumir que ya tienes token y gameId
  gameWs.value = new GameWebSocket(gameId, token)
  
  // Registrar handlers
  gameWs.value.on('player_connected', (message) => {
    // Actualizar lista de jugadores
  })
  
  gameWs.value.on('phase_changed', (message) => {
    currentPhase.value = message.phase
  })
  
  gameWs.value.on('phase_timer', (message) => {
    timeRemaining.value = message.time_remaining
  })
  
  gameWs.value.on('system_message', (message) => {
    if (message.data?.players) {
      players.value = message.data.players
    }
  })
  
  gameWs.value.connect()
})

onUnmounted(() => {
  gameWs.value?.ws?.close()
})
</script>
```

### 3. Manejo de Estados
Se recomienda usar un store (Pinia/Vuex) para manejar el estado del juego compartido entre componentes.

---

## Notas Importantes

1. **AutenticaciÃ³n Obligatoria**: Todas las conexiones requieren un token vÃ¡lido
2. **ReconexiÃ³n**: Implementar lÃ³gica de reconexiÃ³n automÃ¡tica en caso de desconexiÃ³n
3. **Manejo de Errores**: Siempre manejar mensajes de error apropiadamente
4. **Heartbeat**: Responder a pings del servidor para mantener conexiÃ³n
5. **JSON VÃ¡lido**: Todos los mensajes deben ser JSON vÃ¡lido
6. **Case Sensitive**: Los tipos de mensajes son sensibles a mayÃºsculas/minÃºsculas
7. **CORS**: El backend ya estÃ¡ configurado para localhost:5173 y 5174 (Vite)

---

## CÃ³digos de Cierre WebSocket

- **4000**: Error interno del servidor
- **4001**: Token invÃ¡lido o usuario no encontrado
- **1000**: Cierre normal
- **1006**: ConexiÃ³n perdida inesperadamente

---

## ActualizaciÃ³n - Compatibilidad con Frontend

### âœ… Cambios Realizados para Compatibilidad

#### 1. URL Corregida
- **Backend**: `ws://localhost:8000/ws/{game_id}?token={access_token}`
- **Frontend adaptado**: Ahora usa la URL correcta del backend

#### 2. Heartbeat Unificado  
- **Tipo de mensaje**: `heartbeat` (antes el frontend usaba `ping/pong`)
- **Frontend adaptado**: Usa `heartbeat` como el backend

#### 3. Comandos Unificados
- **get_game_status**: Frontend adaptado para usar este comando del backend
- **join_game**: Frontend adaptado para usar este comando del backend

#### 4. Nuevos Tipos de Mensaje (Opcional - Extensiones del Backend)
- `GAME_CONNECTION_STATE`: Estado general de conexiÃ³n del juego  
- `PLAYERS_STATUS_UPDATE`: Actualizaciones especÃ­ficas de estado de jugadores
- `USER_CONNECTION_STATUS`: Estado de conexiÃ³n de usuario especÃ­fico

### ğŸ”„ Adaptadores en Frontend
El frontend ahora incluye adaptadores que convierten mensajes del backend:
- `system_message` â†’ `game_connection_state` (adaptado automÃ¡ticamente)
- `player_connected`/`player_disconnected` â†’ Actualiza estado de conexiÃ³n

### ğŸ“‹ Estado de Compatibilidad
- âœ… **ConexiÃ³n WebSocket**: Compatible
- âœ… **AutenticaciÃ³n**: Compatible
- âœ… **Heartbeat**: Compatible
- âœ… **Comandos bÃ¡sicos**: Compatible  
- âœ… **Estado de juego**: Compatible via adaptadores
- ğŸ”„ **Mensajes especÃ­ficos**: En desarrollo (extensiones opcionales)
